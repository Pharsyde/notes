# Что нужно запомнить программисту переходящему на Python

Когда-то давно, в студенческие годы, меня укусил питон, правда инкубационный период затянулся
и получилось так, что я стал программистом на перле.
Однако в какой-то момент перл исчерпал себя и я решил заняться питоном, сначала просто делал что-то
и разбирался с тем, что нужно для данной задачи, а потом понял, что нужны какие-то систематизированные знания и прочитал несколько книг:
Билл Любанович «Простой Python. Современный стиль программирования»
Дэн Бейдер «Чистый Python. Тонкости программирования для профи»
Бретт Слаткин «Секреты Python: 59 рекомендаций по написанию эффективного кода»
В итоге наокпились какие-то заметки, которые, как мне кажется, могут быть полезны тому кто пожелает мигрировать на питон с других языков.
Актуальными я считаю питон версий выше 3.5 (про второй питон давно пора забыть) т.к. именно такая версия в стабильном дебиане, а значит во всех остальных местах более свежие версии )

## Типизация

Питон динамически типизированный язык т.е. он проверяет соответствие типов
в процессе выполнения, например:

    cat type.py
    a=5
    b='5'
    print(a+b)

    python3 type.py
    ... TypeError: unsupported operand type(s) for +: 'int' and 'str'

Однако, если ваш проект дозрел до необходимости статической типизации, то питон
предоставляет и такую возможность путём использования статического анализитора mypy:

    mypy type.py
    type.py:3: error: Unsupported operand types for + ("int" and "str")

Правда так ловятся не все ошибки

    cat type2.py
    def greeting(name):
        return 'Hello ' + name

        greeting(5)

mypy тут не ругнётся, а при выполнении случиться ошибка, поэтому актуальные версии
питона поддерживают специальный синтаксис для указания типов аргументов функций:

    cat type3.py
    def greeting(name: str) -> str:
        return 'Hello ' + name

        greeting(5)

    mypy type3.py
    type3.py:4: error: Argument 1 to "greeting" has incompatible type "int"; expected "str"

## Переменные и данные

Переменные в питоне не хранят данные, а лишь ссылаются на них, а данные бывают изменяемые (мутабельные) и неизменяемые (иммутабельные).
Например, строки это иммутабельный тип данных, это значит, что саму строку изменить нельзя, можно лишь породить новую, но переменной можно присвоить другое значение, хотя данные при этом не изменятся если они нужны кому-то ещё:

    >>> mystr = 'sss'
    >>> str = mystr
    >>> mystr[0] = 'a'
    ...
      TypeError: 'str' object does not support item assignment
    >>> mystr = 'ssa'
    >>> str
      'sss'

Кстати, о строках, из-за их иммутабельности конкатенация очень большого списка строк сложением или append'ом в цикле может быть не очень эффективной, обычно для таких случаев рекомендуют использовать метод [join](https://docs.python.org/3/library/stdtypes.html#str.join), который ведёт себя немного неожиданно:

    >>> str_list = ['ss', 'dd', 'gg']
    >>> 'XXX'.join(str_list)
    'ssXXXddXXXgg'
    >>> str = 'hello'
    >>> 'XXX'.join(str)
    'hXXXeXXXlXXXlXXXo'

т.е. строка у которой вызывается метод становиться разделитетем и передавать нужно список (итерируемый объект), а не отдельную строку ибо таковая тоже является итерируемым объектом.

Так как переменные это ссылки, то вполне нормальным является желание сделать копию объекта, чтобы не ломать исходный объект, однако тут есть подводный камень - функция [copy](https://docs.python.org/3.5/library/copy.html) копирует только один уровень, что явно не то, что ожидается от функции с таким именем, используете deepcopy.
Аналогичная проблема может возникать при умножении коллекции на скаляр, как недавно разбиралось [тут](https://habr.com/post/422951/).

## Область видимости

Область видимости переменных в питоне ограничена модулем/функцией в которых она определена, но есть тонкость - переменая объявленная в модуле доступна для чтения 

## Аргументы функций

## ООП

ООП в питоне сделано весьма интересно (одни property чего стоят) и это большая тема, однако сапиенс знакомый с ООП вполне может нагуглить всё (или найти на [хабре](https://habr.com/post/114576/)), что ему захочется, поэтому нет смысла повторяться,
единственный минус стандартных классов - шаблонный код во всяких [дандер методах](https://dbader.org/blog/python-dunder-methods), лично мне нравится библиотека [attrs](https://pypi.org/project/attrs/), она значительно более питоническая.
Стоит упомянуть, что так в питоне всё объекты, включая функции и класы, то классы можно создавать динамически (без использования eval) функцией [type](https://docs.python.org/3/library/functions.html?highlight=type#type).
Также стоит почитать про [метаклассы](https://docs.python.org/3/reference/datamodel.html#metaclasses) ([на хабре](https://habr.com/post/145835/)) и [дескрипторы](https://docs.python.org/3/howto/descriptor.html) ([хабр](https://habr.com/post/122082/)).
Особенность, которую стоит запомнить - атрибуты класса и объекта это не одно и тоже, в случае неизменяемых атрибутов это не вызывает проблем так как атрибуты "затеняются" (shadowing) - создаются автоматически атрибуты объекта с таким же именем, а вот в случае изменяемых атрибутов можно получить не совсем то, что ожидалось:

    cat class_attr.py
    class MyClass:
        storage = [7,]
            def __init__(self, number):
                self.number = number

    obj = MyClass(1)
    obj2 = MyClass(2)

    obj.number = 5
    obj.storage.append(8)

    print(obj2.storage, obj2.number)

    python3 class_attr.py
    [7, 8] 2

как можно увидеть - изменяли obj, а изменился и obj2
