# Что нужно запомнить программисту переходящему на Python

Когда-то давно, в студенческие годы, меня укусил питон, правда инкубационный период затянулся
и получилось так, что я стал программистом на перле.
Однако в какой-то момент перл исчерпал себя и я решил заняться питоном, сначала просто делал что-то
и разбирался с тем, что нужно для данной задачи, а потом понял, что нужны какие-то систематизированные знания и прочитал несколько книг:
Билл Любанович «Простой Python. Современный стиль программирования»
Дэн Бейдер «Чистый Python. Тонкости программирования для профи»
Бретт Слаткин «Секреты Python: 59 рекомендаций по написанию эффективного кода»
Которые мне показались вполне подходящими для понимания тонкостей языка.
В итоге у меня накопились какие-то заметки об особенностях питона, которые, как мне кажется, могут быть полезны тому кто пожелает мигрировать на него с других языков.
Актуальными я считаю питон версий выше 3.5 (про второй питон давно пора забыть) т.к. именно такая версия в стабильном дебиане, а значит во всех остальных местах более свежие версии )

## Типизация

Питон динамически типизированный язык т.е. он проверяет соответствие типов
в процессе выполнения, например:

    cat type.py
    a=5
    b='5'
    print(a+b)

    python3 type.py
    ... TypeError: unsupported operand type(s) for +: 'int' and 'str'

Однако, если ваш проект дозрел до необходимости статической типизации, то питон
предоставляет и такую возможность путём использования статического анализитора mypy:

    mypy type.py
    type.py:3: error: Unsupported operand types for + ("int" and "str")

Правда так ловятся не все ошибки

    cat type2.py
    def greeting(name):
        return 'Hello ' + name

        greeting(5)

mypy тут не ругнётся, а при выполнении случиться ошибка, поэтому актуальные версии
питона поддерживают специальный синтаксис для указания типов аргументов функций:

    cat type3.py
    def greeting(name: str) -> str:
        return 'Hello ' + name

        greeting(5)

    mypy type3.py
    type3.py:4: error: Argument 1 to "greeting" has incompatible type "int"; expected "str"

## Переменные и данные

Переменные в питоне не хранят данные, а лишь ссылаются на них, а данные бывают изменяемые (мутабельные) и неизменяемые (иммутабельные).
Например, строки это иммутабельный тип данных, это значит, что саму строку изменить нельзя, можно лишь породить новую, но переменной можно присвоить другое значение, хотя данные при этом не изменятся:

    >>> mystr = 'sss'
    >>> str = mystr
    >>> mystr[0] = 'a'
    ...
      TypeError: 'str' object does not support item assignment
    >>> mystr = 'ssa'
    >>> str
      'sss'

Кстати, о строках, из-за их иммутабельности конкатенация очень большого списка строк сложением или append'ом в цикле может быть не очень эффективной, обычно для таких случаев рекомендуют использовать метод [join](https://docs.python.org/3/library/stdtypes.html#str.join), который ведёт себя немного неожиданно:

    >>> str_list = ['ss', 'dd', 'gg']
    >>> 'XXX'.join(str_list)
    'ssXXXddXXXgg'
    >>> str = 'hello'
    >>> 'XXX'.join(str)
    'hXXXeXXXlXXXlXXXo'

во-первых, строка у которой вызывается метод становиться разделитетем, а не началом новой строки как можно было бы подумать, а во-вторых, передавать нужно список (итерируемый объект), а не отдельную строку ибо таковая тоже является итерируемым объектом.

Так как переменные это ссылки, то вполне нормальным является желание сделать копию объекта, чтобы не ломать исходный объект, однако тут есть подводный камень - функция [copy](https://docs.python.org/3.5/library/copy.html) копирует только один уровень, что явно не то, что ожидается от функции с таким именем, используете deepcopy.
Аналогичная проблема может возникать при умножении коллекции на скаляр, как недавно разбиралось [тут](https://habr.com/post/422951/).

## Область видимости

Область видимости переменных в питоне ограничена модулем/функцией в которых она определена и вложеными функциями, но есть тонкость - переменная по умолчанию доступна для чтения во вложенных пространствах имён, но модификация требует использования специальных ключевых слов nonlocal и global для модификации переменных на один уровень выше или глобальной видимости соответственно.
Например такой код:

    x = 7
    print(id(x))

    def func():
        print(id(x))
        return x

    print(func())

Работает с одной глобальной переменной, а такой:

    x = 7
    print(id(x))

    def func():
        x = 1
        print(id(x))
        return x

    print(func())
    print(x)

уже порождает локальную.
С моей точки зрения это не очень хорошо, по идее любое использование нелокальных переменных в функции это часть публичного интерфейса функции, её сигнатуры, а значит должно объявляться явно и видимо в начале функции.


## Аргументы функций

Питон предоставляет просто шикарные возможности за заданию аргументов функций - позиционные, именованные аргументы и их комбинации.
Также можно задавать значения по умолчанию, но с этим есть одна неочевидная вещь которую нужно запомнить - значения по умолчанию вычисляются один раз при определении функции, это не создаёт никаких проблем, если вы в качестве значения по умолчанию передаёте неизменяемые данные, а если передаются изменяемые данные или динамическое значение, то результат будем чуток неожиданным:

изменяемые данные:

    cat arg_list.py

    def func(arg = []):
        arg.append('x')
            return arg

    print(func())
    print(func())
    print(func())


    python3 arg_list.py
    ['x']
    ['x', 'x']
    ['x', 'x', 'x']

динамическое значение:

    cat arg_now.py

    from datetime import datetime

    def func(arg = datetime.now()):
        return arg

    print(func())
    print(func())
    print(func())


    python3 arg_now.py
    2018-09-28 10:28:40.771879
    2018-09-28 10:28:40.771879
    2018-09-28 10:28:40.771879

## ООП

ООП в питоне сделано весьма интересно (одни property чего стоят) и это большая тема, однако сапиенс знакомый с ООП вполне может нагуглить всё (или найти на [хабре](https://habr.com/post/114576/)), что ему захочется, поэтому нет смысла повторяться,
единственный минус стандартных классов - шаблонный код во всяких [дандер методах](https://dbader.org/blog/python-dunder-methods), лично мне нравится библиотека [attrs](https://pypi.org/project/attrs/), она значительно более питоническая.
Стоит упомянуть, что так в питоне всё объекты, включая функции и класы, то классы можно создавать динамически (без использования eval) функцией [type](https://docs.python.org/3/library/functions.html?highlight=type#type).
Также стоит почитать про [метаклассы](https://docs.python.org/3/reference/datamodel.html#metaclasses) ([на хабре](https://habr.com/post/145835/)) и [дескрипторы](https://docs.python.org/3/howto/descriptor.html) ([хабр](https://habr.com/post/122082/)).
Особенность, которую стоит запомнить - атрибуты класса и объекта это не одно и тоже, в случае неизменяемых атрибутов это не вызывает проблем так как атрибуты "затеняются" (shadowing) - создаются автоматически атрибуты объекта с таким же именем, а вот в случае изменяемых атрибутов можно получить не совсем то, что ожидалось:

    cat class_attr.py
    class MyClass:
        storage = [7,]
            def __init__(self, number):
                self.number = number

    obj = MyClass(1)
    obj2 = MyClass(2)

    obj.number = 5
    obj.storage.append(8)

    print(obj2.storage, obj2.number)

    python3 class_attr.py
    [7, 8] 2

как можно увидеть - изменяли obj, а изменился и obj2
